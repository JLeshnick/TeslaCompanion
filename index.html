<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Viewer - Tesla Companion</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<div id="landing-page">
    <div class="landing-content">
        <div class="landing-logo">Tesla Companion</div>
        <p class="landing-subtitle">Your Toolkit for Viewing Camera Clips, Estimating Trips, Charging, Phantom Drain, and more.</p>
        <div class="feature-list">
            <div class="feature-item">Camera Viewer</div>
            <div class="feature-item">Trip Range Estimator</div>
            <div class="feature-item">Charging Estimator</div>
            <div class="feature-item">Phantom Drain Estimator</div>
        </div>
        <button id="launch-app-btn">Launch Application</button>
    </div>
</div>

<div class="layout-container hidden"> 
    <header class="header">
        <div class="header-top">
            <div class="title-area">
                <div class="title">Tesla Companion</div>
            </div>
            <div class="top-right-controls">
                <button class="btn icon-btn" id="theme-toggle" title="Toggle Theme">
                    <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    <svg id="theme-icon-moon" style="display:none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </button>
                <a href="https://github.com/JLeshnick/TeslaCompanion" target="_blank" class="btn icon-btn" id="github-link" title="View on GitHub">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" style="width: 24px; height: 24px;"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg>
                </a>
            </div>
        </div>
        <div class="main-tabs">
            <a href="howto.html" class="tab-button">How To</a>
            <a href="index.html" class="tab-button active">Camera Viewer</a>
            <a href="trip_planner.html" class="tab-button">Trip Range Estimator</a>
            <a href="charging.html" class="tab-button">Charging Time Estimator</a>
            <a href="phantom_drain.html" class="tab-button">Phantom Drain Estimator</a>
            <a href="about.html" class="tab-button">About</a>
        </div>
    </header>

    <div class="content-container">
        <div id="CameraViewer" class="tab-content active" style="display: flex;">
             <div class="sub-tab-nav">
                <button class="sub-tab-btn active" id="btn-source-local" onclick="switchCameraSource('local')">Local Files</button>
                <button class="sub-tab-btn" id="btn-source-pi" onclick="switchCameraSource('pi')">Raspberry Pi</button>
             </div>
             <div id="camera-controls-container">
                    <div class="header-main">
                            <div class="header-row top-ribbon">
                                <div class="title-area">
                                    <div class="clip-info">
                                        <span class="title-folder-name">No Clips Selected</span>
                                        <div id="event-details-container" style="display: none;">
                                            <div id="event-reason-display" class="event-detail-item"></div>
                                            <div id="event-time-display" class="event-detail-item"></div>
                                            <div id="event-trigger-display" class="event-detail-item"></div>
                                            <div id="event-city-display" class="event-detail-item"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="main-playback-controls">
                                    <div class="event-action-stack">
                                        <button class="btn" id="jump-to-event" style="display: none;" title="Jump to event trigger">Jump to Event</button>
                                        <button class="btn" id="map-button" style="display: none;" title="View on Map">Event Map</button>
                                    </div>
                                    <button class="btn icon-btn previous" title="Previous Clip"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"></path></svg></button>
                                    <button class="btn" id="skip-rewind" title="Rewind 5s">-5s</button>
                                    <button class="btn icon-btn" id="play-pause-button"><svg id="play-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M8 5v14l11-7z"></path></svg><svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg></button>
                                    <button class="btn" id="skip-forward" title="Forward 5s">+5s</button>
                                    <button class="btn icon-btn next" title="Next Clip"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"></path></svg></button>
                                    <div style="display:flex; align-items:center; position:relative;">
                                        <input type="number" id="playback-speed" class="styled-input" title="Playback Speed" value="1" min="0.1" max="16" step="0.1" style="width: 60px; padding-right: 20px;">
                                        <span style="position:absolute; right:8px; color:var(--text-muted-color); font-size:0.8rem; pointer-events:none;">x</span>
                                    </div>
                                    <div class="time-display"><span class="status-dot ready"></span><span id="live-timestamp">00:00</span> / <span id="duration-display">00:00</span></div>
                                    <div class="utility-btn-stack">
                                        <button class="btn icon-btn" id="screenshot-btn" title="Screenshot"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></button>
                                        <button class="btn icon-btn" id="fullscreen-toggle" title="Toggle Fullscreen">
                                            <svg id="maximize-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                                            <svg id="minimize-icon" style="display:none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
                                        </button>
                                    </div>
                                </div>
                                <div class="file-select-stack">
                                    <div id="local-file-controls">
                                        <label for="fileBrowser" class="btn"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px; margin-right: 0.5rem;"><path d="M10 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-8l-2-2z"/></svg>Select Directory</label>
                                        <input type="file" id="fileBrowser" webkitdirectory multiple hidden>
                                    </div>
                                    <div id="pi-file-controls" style="display:none;" class="pi-controls">
                                        <input type="text" id="pi-ip" placeholder="IP (e.g. 192.168.1.173)">
                                        <div style="display:flex; gap:0.25rem;">
                                            <input type="text" id="pi-user" placeholder="User" style="width:50%">
                                            <input type="password" id="pi-pass" placeholder="Pass" style="width:50%">
                                        </div>
                                        <div class="checkbox-group" style="margin-bottom:0; padding:0; justify-content: center;">
                                            <input type="checkbox" id="pi-use-proxy">
                                            <label for="pi-use-proxy" style="font-size:0.8rem; color:var(--text-muted-color);">Use Proxy (localhost:8000)</label>
                                        </div>
                                        <button class="btn" id="pi-connect-btn">Connect</button>
                                    </div>
                                    <select id="date-select" class="styled-input"><option>Select Event</option></select>
                                </div>
                            </div>
                            <div class="header-row progress-container">
                                <div id="event-marker"></div>
                                <div id="timeline-markers"></div>
                                <div id="scrubber-tooltip">00:00</div>
                                <input type="range" id="master-scrubber" min="0" max="100" value="0" step="0.1">
                            </div>
                    </div>
                    <div id="collapsible-controls" class="collapsible-panel">
                            <div class="panel-section">
                                <div class="camera-toggles" id="camera-toggles">
                                    <label class="toggle-label" for="select-all-cameras">All Cameras<label class="switch"><input type="checkbox" id="select-all-cameras" checked><span class="slider"></span></label></label>
                                    <div class="divider"></div>
                                    <label class="toggle-label" for="cam-front">Front<label class="switch"><input type="checkbox" id="cam-front" data-camera="front" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-back">Back<label class="switch"><input type="checkbox" id="cam-back" data-camera="back" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-left-repeater">L Fender<label class="switch"><input type="checkbox" id="cam-left-repeater" data-camera="left_repeater" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-right-repeater">R Fender<label class="switch"><input type="checkbox" id="cam-right-repeater" data-camera="right_repeater" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-left-pillar">L Pillar<label class="switch"><input type="checkbox" id="cam-left-pillar" data-camera="left_pillar" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-right-pillar">R Pillar<label class="switch"><input type="checkbox" id="cam-right-pillar" data-camera="right_pillar" checked><span class="slider"></span></label></label>
                                </div>
                            </div>
                    </div>
             </div>
             <div class="video-grid-container">
                    <div class="video-grid" id="video-grid">
                        <div class="video-container front"><div class="video-label">Front</div><video class="front" muted playsinline></video></div>
                        <div class="video-container back"><div class="video-label">Back</div><video class="back" muted playsinline></video></div>
                        <div class="video-container left_repeater"><div class="video-label">Left Fender</div><video class="left_repeater" muted playsinline></video></div>
                        <div class="video-container right_repeater"><div class="video-label">Right Fender</div><video class="right_repeater" muted playsinline></video></div>
                        <div class="video-container left_pillar"><div class="video-label">Left Pillar</div><video class="left_pillar" muted playsinline></video></div>
                        <div class="video-container right_pillar"><div class="video-label">Right Pillar</div><video class="right_pillar" muted playsinline></video></div>
                    </div>
             </div>
        </div>
    </div>
</div>

<div id="map-container">
    <div id="map-close-button">Ã—</div>
    <iframe id="map-iframe" src="" frameborder="0" allowfullscreen></iframe>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const state = {
            playbackRate: 1, carouselIndex: 0, eventClips: new Map(),
            sortedEventKeys: [], currentEventData: {},
            cameraSource: 'local', // 'local' or 'pi'
            piConfig: { ip: '', user: '', pass: '', useProxy: false },
        };

        const dom = {
            landingPage: document.getElementById('landing-page'),
            launchAppBtn: document.getElementById('launch-app-btn'),
            appContainer: document.querySelector('.layout-container'),
            body: document.body,
            videoGrid: document.querySelector("#video-grid"),
            allVideos: document.querySelectorAll("video"), 
            frontVideo: document.querySelector("video.front"),
            fileBrowser: document.querySelector("#fileBrowser"),
            dateSelector: document.querySelector("#date-select"),
            nextButton: document.querySelector("button.next"),
            previousButton: document.querySelector("button.previous"),
            masterScrubber: document.querySelector("#master-scrubber"),
            liveTimestamp: document.querySelector("#live-timestamp"),
            durationDisplay: document.querySelector("#duration-display"),
            playPauseButton: document.querySelector("#play-pause-button"),
            playIcon: document.querySelector("#play-icon"), 
            pauseIcon: document.querySelector("#pause-icon"),
            statusDot: document.querySelector('.status-dot'),
            eventMarker: document.querySelector("#event-marker"),
            jumpToEventButton: document.querySelector("#jump-to-event"),
            mapButton: document.getElementById('map-button'),
            mapContainer: document.getElementById('map-container'),
            mapIframe: document.getElementById('map-iframe'),
            mapCloseButton: document.getElementById('map-close-button'),
            cameraToggles: document.querySelector("#camera-toggles"),
            selectAllCameras: document.querySelector('#select-all-cameras'),
            themeToggle: document.querySelector('#theme-toggle'),
            themeIconSun: document.querySelector('#theme-icon-sun'),
            themeIconMoon: document.querySelector('#theme-icon-moon'),
            fullscreenToggle: document.getElementById('fullscreen-toggle'),
            maximizeIcon: document.getElementById('maximize-icon'),
            minimizeIcon: document.getElementById('minimize-icon'),
            skipForwardButton: document.querySelector('#skip-forward'),
            skipRewindButton: document.querySelector('#skip-rewind'),
            playbackSpeedSelector: document.querySelector('#playback-speed'),
            scrubberTooltip: document.getElementById('scrubber-tooltip'),
            timelineMarkersContainer: document.getElementById('timeline-markers'),
            collapsibleControls: document.querySelector('#collapsible-controls'),
            titleFolderName: document.querySelector('.title-folder-name'),
            eventDetailsContainer: document.getElementById('event-details-container'),
            eventReasonDisplay: document.getElementById('event-reason-display'),
            eventTimeDisplay: document.getElementById('event-time-display'),
            eventTriggerDisplay: document.getElementById('event-trigger-display'),
            eventCityDisplay: document.getElementById('event-city-display'),
            screenshotBtn: document.querySelector('#screenshot-btn'),
            cameraControlsContainer: document.getElementById('camera-controls-container'),
            // Camera Source Elements
            btnSourceLocal: document.getElementById('btn-source-local'),
            btnSourcePi: document.getElementById('btn-source-pi'),
            localFileControls: document.getElementById('local-file-controls'),
            piFileControls: document.getElementById('pi-file-controls'),
            piIpInput: document.getElementById('pi-ip'),
            piUserInput: document.getElementById('pi-user'),
            piPassInput: document.getElementById('pi-pass'),
            piUseProxy: document.getElementById('pi-use-proxy'),
            piConnectBtn: document.getElementById('pi-connect-btn'),
        };

        const friendlyEventReasons = {
            'sentry_aware_object_detection': 'Sentry: Object Detected',
            'user_interaction_dashcam_icon_tapped': 'Dashcam Saved (Manual)',
            'user_interaction_honk': 'Dashcam Saved (Honk)',
            'sentry_locked_handle_pulled': 'Sentry: Handle Pulled',
            'user_interaction_dashcam_multifunction_selected': 'Dashcam Saved (Manual)',
        };

        window.switchCameraSource = (source) => {
            state.cameraSource = source;
            if (source === 'local') {
                dom.btnSourceLocal.classList.add('active');
                dom.btnSourcePi.classList.remove('active');
                dom.localFileControls.style.display = 'block';
                dom.piFileControls.style.display = 'none';
            } else {
                dom.btnSourceLocal.classList.remove('active');
                dom.btnSourcePi.classList.add('active');
                dom.localFileControls.style.display = 'none';
                dom.piFileControls.style.display = 'flex';
                // Load saved Pi config if available
                if (localStorage.getItem('piConfig')) {
                    const saved = JSON.parse(localStorage.getItem('piConfig'));
                    dom.piIpInput.value = saved.ip || '';
                    dom.piUserInput.value = saved.user || '';
                    dom.piPassInput.value = saved.pass || '';
                    dom.piUseProxy.checked = saved.useProxy || false;
                }
            }
            // Clear current clips when switching source
            resetViewer();
        };

        function resetViewer() {
            state.eventClips.clear();
            state.sortedEventKeys = [];
            dom.dateSelector.innerHTML = '<option>Select Event</option>';
            dom.titleFolderName.textContent = 'No Clips Selected';
            dom.allVideos.forEach(v => { v.src = ''; });
            dom.eventDetailsContainer.style.display = 'none';
            dom.liveTimestamp.textContent = "00:00";
            dom.durationDisplay.textContent = "00:00";
            dom.masterScrubber.value = 0;
            dom.eventMarker.style.display = "none";
            dom.timelineMarkersContainer.innerHTML = '';
            dom.jumpToEventButton.style.display = "none";
            dom.mapButton.style.display = 'none';
        }
        
        const applyTheme = (theme) => {
            if (theme === 'light') {
                dom.body.classList.add('light-mode');
                dom.themeIconSun.style.display = 'none';
                dom.themeIconMoon.style.display = 'block';
            } else {
                dom.body.classList.remove('light-mode');
                dom.themeIconSun.style.display = 'block';
                dom.themeIconMoon.style.display = 'none';
            }
        }

        async function connectToPi() {
            const ip = dom.piIpInput.value.trim();
            const user = dom.piUserInput.value.trim();
            const pass = dom.piPassInput.value.trim();
            const useProxy = dom.piUseProxy.checked;

            if (!ip) {
                alert("Please enter an IP address.");
                return;
            }

            // Save config
            state.piConfig = { ip, user, pass, useProxy };
            localStorage.setItem('piConfig', JSON.stringify(state.piConfig));

            dom.titleFolderName.textContent = "Connecting...";
            
            const authHeaders = new Headers();
            if (user && pass) {
                authHeaders.set('Authorization', 'Basic ' + btoa(user + ":" + pass));
            }

            try {
                // Ensure protocol is present
                const baseUrl = ip.startsWith('http') ? ip : `http://${ip}`;
                let url = `${baseUrl}/cgi-bin/videolist.sh`;
                
                if (useProxy) {
                    url = `http://localhost:8000/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(url, { headers: authHeaders });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                processRemoteFileList(text, baseUrl, authHeaders);

            } catch (error) {
                console.error("Connection failed:", error);
                dom.titleFolderName.textContent = "Connection Failed";
                alert(`Failed to connect to ${ip}.\n\nError: ${error.message}\n\nNote: If accessing from a local file, browser security (CORS) may block the request.\nTry enabling "Use Proxy" and running the python cors_proxy.py script.`);
            }
        }

        function processRemoteFileList(fileListText, baseUrl, authHeaders) {
            state.eventClips.clear();
            state.sortedEventKeys = [];
            dom.dateSelector.innerHTML = '<option>Select Event</option>';

            const lines = fileListText.split('\n');
            
            const useProxy = state.piConfig.useProxy;

            // Scan for SentryClips AND SavedClips to count events per day and store for markers
            const eventsMap = new Map(); // Date -> [{ time, type, sequenceName }, ...]
            
            for (const lineRaw of lines) {
                 const line = lineRaw.trim();
                 if (!line) continue;
                 if (line.startsWith('SentryClips') || line.startsWith('SavedClips')) {
                     const parts = line.split('/');
                     if (parts.length >= 2) {
                         const group = parts[0];
                         const sequenceName = parts[1]; 
                         const dateMatch = sequenceName.match(/^(\d{4}-\d{2}-\d{2})/);
                         if (dateMatch) {
                             const date = dateMatch[1];
                             if (!eventsMap.has(date)) eventsMap.set(date, new Map());
                             
                             if (!eventsMap.get(date).has(sequenceName)) {
                                 const isoTime = sequenceName.substring(0, 10) + 'T' + sequenceName.substring(11).replace(/-/g, ':');
                                 const eventDate = new Date(isoTime);
                                 
                                 eventsMap.get(date).set(sequenceName, {
                                     time: eventDate,
                                     type: group === 'SentryClips' ? 'sentry' : 'saved',
                                     sequenceName: sequenceName
                                 });
                             }
                         }
                     }
                 }
            }
            state.eventsMap = eventsMap;

            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line) continue;
                
                const parts = line.split('/');
                if (parts.length < 3) continue;

                const [group, sequenceName, filename] = parts;
                
                if (!['RecentClips', 'SavedClips', 'SentryClips'].includes(group)) continue;
                
                if (!state.eventClips.has(sequenceName)) {
                    state.eventClips.set(sequenceName, { 
                        playlists: { front: [], back: [], left_repeater: [], right_repeater: [], left_pillar: [], right_pillar: [] }, 
                        eventJson: null, 
                        fullPath: line,
                        isRemote: true,
                        baseUrl: baseUrl,
                        authHeaders: authHeaders
                    });
                }

                const eventData = state.eventClips.get(sequenceName);
                
                let cameraType = null;
                if (filename.includes('front')) cameraType = 'front';
                else if (filename.includes('back')) cameraType = 'back';
                else if (filename.includes('left_repeater')) cameraType = 'left_repeater';
                else if (filename.includes('right_repeater')) cameraType = 'right_repeater';
                else if (filename.includes('left_pillar')) cameraType = 'left_pillar';
                else if (filename.includes('right_pillar')) cameraType = 'right_pillar';

                if (cameraType && filename.endsWith('.mp4')) {
                    let fakeName = filename;
                    if (!filename.match(/^\d{4}-\d{2}-\d{2}/)) {
                        fakeName = `${sequenceName}-${filename}`;
                    }

                    let fileUrl = `${baseUrl}/TeslaCam/${line}`;
                    if (useProxy) {
                        fileUrl = `http://localhost:8000/proxy?url=${encodeURIComponent(fileUrl)}`;
                    }

                    const remoteFile = {
                        name: fakeName,
                        url: fileUrl, 
                        isRemote: true
                    };
                    eventData.playlists[cameraType].push(remoteFile);
                } else if (filename === 'event.json') {
                    let jsonUrl = `${baseUrl}/TeslaCam/${line}`;
                    if (useProxy) {
                        jsonUrl = `http://localhost:8000/proxy?url=${encodeURIComponent(jsonUrl)}`;
                    }
                    eventData.eventJson = {
                        name: 'event.json',
                        url: jsonUrl,
                        isRemote: true,
                        text: async () => {
                            const res = await fetch(jsonUrl, { headers: authHeaders });
                            return await res.text();
                        }
                    };
                }
            }

            // Sort playlists for each event
            for (const [_, data] of state.eventClips.entries()) { 
                for (const camera in data.playlists) {
                    data.playlists[camera].sort((a, b) => a.name.localeCompare(b.name));
                }
            }

            // For dropdown, we only want keys that look like dates (RecentClips days)
            const allKeys = Array.from(state.eventClips.keys()).sort();
            state.sortedEventKeys = allKeys;
            
            const dateKeys = allKeys.filter(k => k.match(/^\d{4}-\d{2}-\d{2}$/));
            
            if (dateKeys.length === 0) {
                 if (allKeys.length === 0) {
                    dom.titleFolderName.textContent = 'No Clips Found on Pi';
                    dom.dateSelector.innerHTML = '<option>No Events Found</option>';
                    return;
                 }
            }

            dom.dateSelector.innerHTML = '';
            const keysToShow = dateKeys.length > 0 ? dateKeys : allKeys;
            
            keysToShow.forEach((key) => { 
                const index = state.sortedEventKeys.indexOf(key);
                const option = document.createElement("option"); 
                
                const dateMatch = key.match(/^(\d{4}-\d{2}-\d{2})/);
                if (dateMatch && key.length === 10) {
                     const dateStr = dateMatch[1];
                     const eventsForDate = eventsMap.get(dateStr);
                     const eventCount = eventsForDate ? eventsForDate.size : 0;
                     option.innerText = `${key} (${eventCount} events)`;
                } else {
                    option.innerText = key;
                }
                
                option.value = index; 
                dom.dateSelector.appendChild(option); 
            });
            
            if (dom.dateSelector.options.length > 0) {
                dom.dateSelector.selectedIndex = 0;
                loadEvent(parseInt(dom.dateSelector.value));
            }
             dom.titleFolderName.textContent = `Found ${keysToShow.length} Days`;
        }

        async function loadEvent(index) {
            state.carouselIndex = index;
            if (index < 0 || index >= state.sortedEventKeys.length) return;
            pauseVideos();
            dom.masterScrubber.value = 0;
            dom.liveTimestamp.textContent = "00:00";
            dom.durationDisplay.textContent = "00:00";
            dom.eventMarker.style.display = "none";
            dom.jumpToEventButton.style.display = "none";
            dom.mapButton.style.display = 'none';
            dom.eventDetailsContainer.style.display = 'none';
            dom.eventReasonDisplay.innerHTML = '';
            dom.eventTimeDisplay.innerHTML = '';
            dom.eventTriggerDisplay.innerHTML = '';
            dom.eventCityDisplay.innerHTML = '';
            dom.timelineMarkersContainer.innerHTML = '';
            document.querySelectorAll('.video-container').forEach(c => c.classList.remove('triggered'));

            const eventKey = state.sortedEventKeys[index];
            const eventData = state.eventClips.get(eventKey);
            state.currentEventData = {
                playlists: eventData.playlists, clipDurations: [],
                totalDuration: 0, eventTriggerOffset: -1, firstClipTime: null,
                playlistIndices: { front: 0, back: 0, left_repeater: 0, right_repeater: 0, left_pillar: 0, right_pillar: 0 }
            };
            dom.titleFolderName.textContent = eventKey;
            dom.dateSelector.selectedIndex = index;

            let earliestFile = null;
            for (const camera in eventData.playlists) {
                if (eventData.playlists[camera].length > 0) {
                    if (!earliestFile || eventData.playlists[camera][0].name < earliestFile.name) {
                        earliestFile = eventData.playlists[camera][0];
                    }
                }
            }

            if (!earliestFile) return;

            const firstClipNameMatch = earliestFile.name.match(/^(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
            if (firstClipNameMatch) {
                const dateTimeString = firstClipNameMatch[1];
                const formattedDateTimeString = dateTimeString.substring(0, 10) + 'T' + dateTimeString.substring(11).replace(/-/g, ':');
                state.currentEventData.firstClipTime = new Date(formattedDateTimeString);
            } else {
                state.currentEventData.firstClipTime = null;
            }

            const masterPlaylist = state.currentEventData.playlists.front;
            if(masterPlaylist.length > 0) {
                state.currentEventData.clipDurations = await Promise.all(masterPlaylist.map(getVideoDuration));
                state.currentEventData.totalDuration = state.currentEventData.clipDurations.reduce((a, b) => a + b, 0);
            } else {
                state.currentEventData.clipDurations = [];
                state.currentEventData.totalDuration = 0;
            }

            if (state.currentEventData.firstClipTime) {
                updateLiveTimestamp(0);
                const endClipTime = new Date(state.currentEventData.firstClipTime.getTime() + (state.currentEventData.totalDuration * 1000));
                dom.durationDisplay.textContent = formatLocalTime(endClipTime);
            } else {
                dom.liveTimestamp.textContent = formatTime(0);
                dom.durationDisplay.textContent = formatTime(state.currentEventData.totalDuration);
            }

            if (state.currentEventData.firstClipTime && state.currentEventData.totalDuration > 0) {
                 const dateStr = eventKey.substring(0, 10);
                 if (state.eventsMap && state.eventsMap.has(dateStr)) {
                     const events = state.eventsMap.get(dateStr);
                     events.forEach((eventInfo, sequenceName) => {
                         const diffSeconds = (eventInfo.time.getTime() - state.currentEventData.firstClipTime.getTime()) / 1000;
                         
                         if (diffSeconds >= 0 && diffSeconds <= state.currentEventData.totalDuration) {
                             const marker = document.createElement('div');
                             marker.className = `timeline-marker ${eventInfo.type}`;
                             marker.style.left = `${(diffSeconds / state.currentEventData.totalDuration) * 100}%`;
                             marker.title = `${eventInfo.type === 'sentry' ? 'Sentry' : 'Saved'}: ${formatLocalTime(eventInfo.time)}`;
                             
                             marker.addEventListener('click', (e) => {
                                 e.stopPropagation();
                                 seekAllVideos(diffSeconds);
                             });
                             dom.timelineMarkersContainer.appendChild(marker);
                         }
                     });
                 }
            }
            
            if(eventData.eventJson) {
                try {
                    const jsonContent = await eventData.eventJson.text();
                    const jsonData = JSON.parse(jsonContent);
                    const eventTimeFromJSON = new Date(jsonData.timestamp);
                    const rawReason = jsonData.reason;
                    const isManualSave = rawReason.startsWith('user_interaction');
                    
                    dom.eventDetailsContainer.style.display = 'block';
                    const friendlyReason = friendlyEventReasons[rawReason] || rawReason.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    dom.eventReasonDisplay.innerHTML = `Event: <strong>${friendlyReason}</strong>`;
                    dom.eventTimeDisplay.innerHTML = `Event Time: <strong>${formatLocalTime(eventTimeFromJSON)}</strong>`;
                    if (jsonData.city) {
                        dom.eventCityDisplay.innerHTML = `Event City: <strong>${jsonData.city}</strong>`;
                    }
                     if (jsonData.est_lat && jsonData.est_lon) {
                        state.currentEventData.location = { lat: jsonData.est_lat, lon: jsonData.est_lon };
                        dom.mapButton.style.display = 'inline-flex';
                    }
                    const cameraIndexMap = { 0: 'front', 3: 'left_pillar', 4: 'right_pillar', 5: 'left_repeater', 6: 'right_repeater', 7: 'back' };
                    const triggerCameraName = cameraIndexMap[parseInt(jsonData.camera, 10)];
                    if (triggerCameraName) {
                        const displayName = triggerCameraName.replace('_repeater', ' Fender').replace('_pillar', ' Pillar').replace(/_/g, ' ');
                        dom.eventTriggerDisplay.innerHTML = `Trigger: <strong>${displayName.charAt(0).toUpperCase() + displayName.slice(1)}</strong>`;
                        const triggerContainer = document.querySelector(`.video-container.${triggerCameraName}`);
                        if(triggerContainer) triggerContainer.classList.add('triggered');
                    }

                    if (state.currentEventData.firstClipTime && state.currentEventData.totalDuration > 0) {
                        let offset = (eventTimeFromJSON.getTime() - state.currentEventData.firstClipTime.getTime()) / 1000;

                        if (isManualSave) {
                            const diffFromEnd = Math.abs(offset - state.currentEventData.totalDuration);
                            if (diffFromEnd > 1800) { 
                                const hourDifference = Math.round(offset / 3600);
                                if (hourDifference !== 0) {
                                    offset = state.currentEventData.totalDuration - 5; 
                                }
                            }
                        } else {
                             if (Math.abs(offset) > (state.currentEventData.totalDuration + 60)) {
                                const hourDifference = Math.round(offset / 3600);
                                if (hourDifference !== 0) {
                                    offset -= hourDifference * 3600;
                                }
                            }
                        }

                        if (offset >= -10 && offset <= state.currentEventData.totalDuration + 10) { 
                            state.currentEventData.eventTriggerOffset = Math.max(0, Math.min(offset, state.currentEventData.totalDuration));
                            updateEventMarkerPosition();
                            dom.eventMarker.style.display = "block";
                            dom.jumpToEventButton.style.display = "inline-flex";
                        }
                    }
                } catch (error) { console.error("Error processing event.json:", error); }
            }

            const loadPromises = [];
            dom.allVideos.forEach(video => {
                const cameraType = video.className.split(' ')[0];
                const playlist = state.currentEventData.playlists[cameraType];
                const fileToLoad = playlist && playlist.length > 0 ? playlist[0] : null;
                loadPromises.push(loadVideo(video, fileToLoad));
            });
            await Promise.all(loadPromises);
        }

        function loadVideo(videoElement, file) {
            return new Promise((resolve) => {
                if (videoElement.src.startsWith('blob:')) {
                    URL.revokeObjectURL(videoElement.src);
                }
                
                videoElement.playbackRate = state.playbackRate;
                videoElement.preload = "auto";

                if (!file) {
                    videoElement.src = '';
                    resolve();
                    return;
                }

                videoElement.addEventListener('canplay', function onCanPlay() {
                    resolve();
                }, { once: true });
                
                videoElement.addEventListener('error', function onError(e) {
                    console.error(`Error loading video file: ${file.name}`, e);
                    resolve();
                }, { once: true });

                if (file.isRemote) {
                    videoElement.src = file.url;
                    if (state.piConfig && state.piConfig.user && state.piConfig.pass) {
                        try {
                            if (state.piConfig.useProxy) {
                                // URL already proxied
                            } else {
                                const urlObj = new URL(file.url);
                                urlObj.username = state.piConfig.user;
                                urlObj.password = state.piConfig.pass;
                                videoElement.src = urlObj.toString();
                            }
                        } catch (e) {
                            videoElement.src = file.url;
                        }
                    } else {
                        videoElement.src = file.url;
                    }

                } else {
                    videoElement.src = URL.createObjectURL(file);
                }
            });
        }

        function updatePlayButtonUI(isPlaying) {
            dom.playIcon.style.display = isPlaying ? 'none' : 'block';
            dom.pauseIcon.style.display = isPlaying ? 'block' : 'none';
            dom.statusDot.classList.toggle('ready', !isPlaying);
            dom.statusDot.classList.toggle('playing', isPlaying);
        }
        function playVideos() {
            updatePlayButtonUI(true);
            dom.allVideos.forEach(v => { 
                if (v.src && v.paused) {
                    v.play().catch(error => console.error(`Play failed for ${v.className}:`, error));
                }
            });
        }
        function pauseVideos() { updatePlayButtonUI(false); dom.allVideos.forEach(v => v.pause()); }
        function playPause() { dom.frontVideo.paused && dom.frontVideo.src ? playVideos() : pauseVideos(); }
        function skipTo(seconds) { seekAllVideos(getCurrentTime() + seconds); }
        function setPlaybackSpeed(rate) {
            state.playbackRate = parseFloat(rate);
            dom.allVideos.forEach(video => { video.playbackRate = state.playbackRate; });
        }
        function seekAllVideos(targetTime) {
            if (isNaN(targetTime)) targetTime = 0;
            targetTime = Math.max(0, Math.min(targetTime, state.currentEventData.totalDuration));
            let timeIntoPlaylist = 0;
            let targetClipIndex = -1;
            for (let i = 0; i < state.currentEventData.clipDurations.length; i++) {
                if (targetTime <= timeIntoPlaylist + state.currentEventData.clipDurations[i] + 0.1) {
                    targetClipIndex = i; break;
                }
                timeIntoPlaylist += state.currentEventData.clipDurations[i];
            }
            if (targetClipIndex === -1) targetClipIndex = state.currentEventData.clipDurations.length - 1;
            const timeInTargetClip = targetTime - timeIntoPlaylist;
            const wasPlaying = !dom.frontVideo.paused;
            dom.allVideos.forEach(video => {
                const camera = video.className.split(' ')[0];
                state.currentEventData.playlistIndices[camera] = targetClipIndex;
                const playlist = state.currentEventData.playlists[camera];
                if (playlist && playlist[targetClipIndex]) {
                    if (!video.src.endsWith(playlist[targetClipIndex].name)) loadVideo(video, playlist[targetClipIndex]);
                    video.currentTime = timeInTargetClip;
                }
            });
            if (wasPlaying) playVideos();
        }
        function getCurrentTime() {
            if(!state.currentEventData?.clipDurations?.length) return 0;
            let elapsed = 0;
            for (let i = 0; i < state.currentEventData.playlistIndices.front; i++) {
                elapsed += (state.currentEventData.clipDurations[i] || 0);
            }
            return elapsed + dom.frontVideo.currentTime;
        }
        function updateLiveTimestamp(currentTimeOverride) {
            const currentTime = currentTimeOverride !== undefined ? currentTimeOverride : getCurrentTime();
            if (!state.currentEventData.firstClipTime) {
                dom.liveTimestamp.textContent = formatTime(currentTime);
                return;
            }
            const liveTime = new Date(state.currentEventData.firstClipTime.getTime() + (currentTime * 1000));
            dom.liveTimestamp.textContent = formatLocalTime(liveTime);
        }
        function updateEventMarkerPosition() { if (state.currentEventData.eventTriggerOffset > 0 && state.currentEventData.totalDuration > 0) dom.eventMarker.style.left = `${(state.currentEventData.eventTriggerOffset / state.currentEventData.totalDuration) * 100}%`; }
        function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return "0:00"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs.toString().padStart(2, '0')}`; }
        
        function formatLocalTime(date) { 
            if (!date || isNaN(date.getTime())) return '--:--:--'; 
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }); 
        }

        function getVideoDuration(file) { 
            return new Promise(resolve => { 
                if (file.isRemote) {
                    resolve(60);
                    return;
                }
                const v = document.createElement('video'); 
                v.preload = 'metadata'; 
                v.onloadedmetadata = () => { 
                    URL.revokeObjectURL(v.src); 
                    resolve(v.duration); 
                }; 
                v.onerror = () => resolve(0); 
                v.src = URL.createObjectURL(file); 
            }); 
        }
        
        function toggleFullscreen() {
            dom.body.classList.toggle('fullscreen-active');
            const isFullscreen = dom.body.classList.contains('fullscreen-active');
            dom.maximizeIcon.style.display = isFullscreen ? 'none' : 'block';
            dom.minimizeIcon.style.display = isFullscreen ? 'block' : 'none';
        }

        function closeMap() {
            dom.mapContainer.style.display = 'none';
            dom.mapIframe.src = '';
        }

        // --- Attach Event Listeners ---
        dom.piConnectBtn.addEventListener('click', connectToPi);
        dom.launchAppBtn.addEventListener('click', () => {
            sessionStorage.setItem('appLaunched', 'true');
            dom.landingPage.classList.add('hidden');
            dom.appContainer.classList.remove('hidden');
        });
        dom.themeToggle.addEventListener('click', () => {
            const newTheme = dom.body.classList.contains('light-mode') ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        });
        dom.playPauseButton.addEventListener('click', playPause);
        dom.dateSelector.addEventListener("change", (e) => loadEvent(parseInt(e.target.value)));
        dom.nextButton.addEventListener("click", () => { if (state.carouselIndex < state.sortedEventKeys.length - 1) loadEvent(++state.carouselIndex); });
        dom.previousButton.addEventListener("click", () => { if (state.carouselIndex > 0) loadEvent(--state.carouselIndex); });
        dom.jumpToEventButton.addEventListener("click", () => seekAllVideos(state.currentEventData.eventTriggerOffset));
        dom.skipForwardButton.addEventListener('click', () => skipTo(5));
        dom.skipRewindButton.addEventListener('click', () => skipTo(-5));
        dom.playbackSpeedSelector.addEventListener('input', (e) => setPlaybackSpeed(e.target.value));
        
        dom.masterScrubber.addEventListener('mousemove', (e) => {
            if (!state.currentEventData.totalDuration) return;
            const rect = dom.masterScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            const percentage = Math.max(0, Math.min(1, x / width));
            const time = percentage * state.currentEventData.totalDuration;
            dom.scrubberTooltip.style.left = `${percentage * 100}%`;
            dom.scrubberTooltip.style.opacity = '1';
            if (state.currentEventData.firstClipTime) {
                 const hoverTime = new Date(state.currentEventData.firstClipTime.getTime() + (time * 1000));
                 dom.scrubberTooltip.textContent = formatLocalTime(hoverTime);
            } else {
                 dom.scrubberTooltip.textContent = formatTime(time);
            }
        });
        dom.masterScrubber.addEventListener('mouseout', () => {
            dom.scrubberTooltip.style.opacity = '0';
        });

        dom.selectAllCameras.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            dom.cameraToggles.querySelectorAll('input[data-camera]').forEach(checkbox => {
                checkbox.checked = isChecked; 
                document.querySelector(`.video-container.${checkbox.dataset.camera}`)?.classList.toggle('hidden', !isChecked);
            });
            dom.videoGrid.classList.toggle('single-view-mode', Array.from(dom.cameraToggles.querySelectorAll('input[data-camera]')).filter(cb => cb.checked).length === 1);
        });
        dom.cameraToggles.addEventListener("change", (e) => {
            if (e.target.dataset.camera) { 
                document.querySelector(`.video-container.${e.target.dataset.camera}`)?.classList.toggle('hidden', !e.target.checked);
                const individualCheckboxes = Array.from(dom.cameraToggles.querySelectorAll('input[data-camera]'));
                const checkedCount = individualCheckboxes.filter(cb => cb.checked).length;
                dom.videoGrid.classList.toggle('single-view-mode', checkedCount === 1);
                dom.selectAllCameras.checked = (checkedCount === individualCheckboxes.length);
            }
        });
        dom.masterScrubber.addEventListener("input", () => { if (state.currentEventData.totalDuration) updateLiveTimestamp((dom.masterScrubber.value / 100) * state.currentEventData.totalDuration); });
        dom.masterScrubber.addEventListener("change", () => { if (state.currentEventData.totalDuration) seekAllVideos((dom.masterScrubber.value / 100) * state.currentEventData.totalDuration); });
        dom.frontVideo.addEventListener("timeupdate", () => {
            if (!state.currentEventData.totalDuration || dom.masterScrubber.matches(':active')) return;
            dom.masterScrubber.value = (getCurrentTime() / state.currentEventData.totalDuration) * 100;
            updateLiveTimestamp();
        });

        dom.allVideos.forEach(video => {
            video.addEventListener("ended", async (e) => {
                const wasPlaying = dom.playIcon.style.display === 'none';
                const camera = e.target.className.split(' ')[0];
                if (!state.currentEventData.playlists || !state.currentEventData.playlists[camera]) return;
                const currentIdx = ++state.currentEventData.playlistIndices[camera];
                const playlist = state.currentEventData.playlists[camera];
                if (playlist && currentIdx < playlist.length) {
                    await loadVideo(e.target, playlist[currentIdx]);
                    if (wasPlaying) {
                        e.target.play().catch(err => { if (err.name !== 'AbortError') console.error('Error playing next clip:', err); });
                    }
                } else if (camera === 'front') {
                    if (state.carouselIndex < state.sortedEventKeys.length - 1) {
                        await loadEvent(++state.carouselIndex);
                        if (wasPlaying) playVideos();
                    } else {
                        pauseVideos();
                    }
                }
            });
        });

        document.querySelectorAll('.video-container').forEach(container => {
            container.addEventListener('dblclick', (e) => {
                const grid = dom.videoGrid;
                const clickedContainer = e.currentTarget;
                if (grid.classList.contains('expanded-view')) {
                    if (clickedContainer.classList.contains('expanded')) {
                        grid.classList.remove('expanded-view');
                        clickedContainer.classList.remove('expanded');
                    }
                } else {
                    grid.classList.add('expanded-view');
                    clickedContainer.classList.add('expanded');
                }
            });
        });
        dom.fileBrowser.addEventListener("change", function(e) {
            state.eventClips.clear(); 
            state.sortedEventKeys = []; 
            dom.dateSelector.innerHTML = '<option>Select Event</option>';
            dom.titleFolderName.textContent = 'No Clips Selected';
            for (const file of e.target.files) {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length < 2) continue;
                const eventId = pathParts[pathParts.length - 2];
                if (!state.eventClips.has(eventId)) state.eventClips.set(eventId, { playlists: { front: [], back: [], left_repeater: [], right_repeater: [], left_pillar: [], right_pillar: [] }, eventJson: null, fullPath: file.webkitRelativePath });
                const group = state.eventClips.get(eventId);
                const videoMatch = file.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})-(.+?)\.mp4$/);
                if (videoMatch && group.playlists[videoMatch[2]]) group.playlists[videoMatch[2]].push(file);
                if (file.name === "event.json") group.eventJson = file;
            }
            for (const [_, data] of state.eventClips.entries()) { for (const camera in data.playlists) data.playlists[camera].sort((a, b) => a.name.localeCompare(b.name)); }
            state.sortedEventKeys = Array.from(state.eventClips.keys()).sort();
            if (state.sortedEventKeys.length === 0) { dom.titleFolderName.textContent = 'No Clips Found'; dom.dateSelector.innerHTML = '<option>No Events Found</option>'; return; }
            dom.dateSelector.innerHTML = '';
            state.sortedEventKeys.forEach((key, index) => { const option = document.createElement("option"); option.innerText = key; option.value = index; dom.dateSelector.appendChild(option); });
            loadEvent(0);
        });
        dom.screenshotBtn.addEventListener('click', () => {
            const visibleContainers = [...dom.videoGrid.querySelectorAll('.video-container:not(.hidden)')];
            if (visibleContainers.length === 0) return;
            const firstVideo = visibleContainers[0].querySelector('video');
            if (!firstVideo.src || firstVideo.videoWidth === 0) return;
            const videoWidth = firstVideo.videoWidth;
            const videoHeight = firstVideo.videoHeight;
            const gridMapping = { left_pillar: { col: 0, row: 0 }, front: { col: 1, row: 0 }, right_pillar: { col: 2, row: 0 }, left_repeater: { col: 0, row: 1 }, back: { col: 1, row: 1 }, right_repeater: { col: 2, row: 1 }, };
            const canvas = document.createElement('canvas');
            canvas.width = videoWidth * 3;
            canvas.height = videoHeight * 2;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            visibleContainers.forEach(container => {
                const video = container.querySelector('video');
                const cameraType = [...container.classList].find(c => gridMapping[c]);
                if (cameraType && video.videoWidth > 0) {
                    const { col, row } = gridMapping[cameraType];
                    const dx = col * videoWidth;
                    const dy = row * videoHeight;
                    ctx.drawImage(video, dx, dy, videoWidth, videoHeight);
                }
            });
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `Tesla-Companion-Screenshot-${timestamp}.jpg`;
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
        });
        dom.fullscreenToggle.addEventListener('click', toggleFullscreen);
        dom.mapButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (state.currentEventData.location) {
                const { lat, lon } = state.currentEventData.location;
                const mapUrl = `https://www.google.com/maps?q=${lat},${lon}&hl=es;z=14&output=embed`;
                dom.mapIframe.src = mapUrl;
                dom.mapContainer.style.display = 'flex';
            }
        });
        dom.mapCloseButton.addEventListener('click', closeMap);
        dom.mapContainer.addEventListener('click', (e) => { if (e.target === dom.mapContainer) closeMap(); });
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            switch(e.key) {
                case ' ': e.preventDefault(); playPause(); break;
                case 'ArrowLeft': e.preventDefault(); skipTo(-5); break;
                case 'ArrowRight': e.preventDefault(); skipTo(5); break;
                case 'ArrowUp': e.preventDefault(); if (state.carouselIndex > 0) loadEvent(--state.carouselIndex); break;
                case 'ArrowDown': e.preventDefault(); if (state.carouselIndex < state.sortedEventKeys.length - 1) loadEvent(++state.carouselIndex); break;
                case 'Escape': if (dom.body.classList.contains('fullscreen-active')) { toggleFullscreen(); } closeMap(); break;
            }
        });


        // --- Initial App State ---
        applyTheme(localStorage.getItem('theme') || 'dark');
        dom.cameraControlsContainer.style.display = 'block'; 
        
        // Splash Screen Logic
        if (sessionStorage.getItem('appLaunched')) {
            dom.landingPage.classList.add('hidden');
            dom.appContainer.classList.remove('hidden');
        }
    });
</script>

</body>
