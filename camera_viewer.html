<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Viewer - Tesla Companion</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <style>
        .playback-speed-control {
            background: var(--control-bg-color);
            padding: 0.25rem 0.5rem;
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 38px; 
        }
        /* Dual Player Styles */
        .video-container video { display: none; width: 100%; height: 100%; object-fit: contain; }
        .video-container video.active { display: block; }
    </style>
</head>
<body>

<div class="layout-container"> 
    <header class="header">
        <div class="header-top">
            <div class="title-area">
                <div class="title">Tesla Companion</div>
            </div>
            <div class="top-right-controls">
                <button class="btn icon-btn" id="theme-toggle" title="Toggle Theme">
                    <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    <svg id="theme-icon-moon" style="display:none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </button>
                <a href="https://github.com/JLeshnick/TeslaCompanion" target="_blank" class="btn icon-btn" id="github-link" title="View on GitHub">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" style="width: 24px; height: 24px;"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg>
                </a>
            </div>
        </div>
        <div class="main-tabs">
            <a href="index.html" class="tab-button">Home</a>
            <a href="camera_viewer.html" class="tab-button active">Camera Viewer</a>
            <a href="trip_planner.html" class="tab-button">Trip Range Estimator</a>
            <a href="charging.html" class="tab-button">Charging Time Estimator</a>
            <a href="phantom_drain.html" class="tab-button">Phantom Drain Estimator</a>
            <a href="howto.html" class="tab-button">How To</a>
            <a href="about.html" class="tab-button">About</a>
        </div>
    </header>

    <div class="content-container">
        <div id="CameraViewer" class="tab-content active" style="display: flex;">
             <div class="sub-tab-nav">
                <button class="sub-tab-btn active" id="btn-source-local" onclick="switchCameraSource('local')">Local Files</button>
                <button class="sub-tab-btn" id="btn-source-pi" onclick="switchCameraSource('pi')">Raspberry Pi</button>
             </div>
             <div id="camera-controls-container">
                    <div class="header-main">
                            <div class="header-row top-ribbon">
                                <div class="title-area">
                                    <div class="clip-info">
                                        <span class="title-folder-name">No Clips Selected</span>
                                        <div id="event-details-container" style="display: none;">
                                            <div id="event-reason-display" class="event-detail-item"></div>
                                            <div id="event-time-display" class="event-detail-item"></div>
                                            <div id="event-trigger-display" class="event-detail-item"></div>
                                            <div id="event-city-display" class="event-detail-item"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="main-playback-controls">
                                    <div class="event-action-stack">
                                        <button class="btn" id="jump-to-event" style="display: none;" title="Jump to event trigger">Jump to Event</button>
                                        <button class="btn" id="map-button" style="display: none;" title="View on Map">Event Map</button>
                                    </div>
                                    <button class="btn icon-btn previous" title="Previous Clip"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"></path></svg></button>
                                    <button class="btn" id="skip-rewind" title="Rewind 5s">-5s</button>
                                    <button class="btn icon-btn" id="play-pause-button"><svg id="play-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M8 5v14l11-7z"></path></svg><svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg></button>
                                    <button class="btn" id="skip-forward" title="Forward 5s">+5s</button>
                                    <button class="btn icon-btn next" title="Next Clip"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" height="24" viewBox="0 0 24 24" width="24"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"></path></svg></button>
                                    
                                    <!-- Playback Speed Slider -->
                                    <div class="playback-speed-control">
                                        <span id="speed-display" style="font-weight:600; min-width:3ch; text-align:right;">1.0x</span>
                                        <input type="range" id="playback-speed" min="0" max="100" value="50" style="width: 80px; padding:0; margin:0; height:6px;">
                                        <button class="btn" id="reset-speed" title="Reset to 1x" style="padding:0.2rem 0.5rem; height: 24px; font-size:0.7rem; min-width: auto;">1x</button>
                                    </div>

                                    <div class="time-display"><span class="status-dot ready"></span><span id="live-timestamp">00:00</span> / <span id="duration-display">00:00</span></div>
                                    <div class="utility-btn-stack">
                                        <button class="btn icon-btn" id="screenshot-btn" title="Screenshot"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></button>
                                        <button class="btn icon-btn" id="fullscreen-toggle" title="Toggle Fullscreen">
                                            <svg id="maximize-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                                            <svg id="minimize-icon" style="display:none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
                                        </button>
                                    </div>
                                </div>
                                <div class="file-select-stack">
                                    <div id="local-file-controls">
                                        <label for="fileBrowser" class="btn"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px; margin-right: 0.5rem;"><path d="M10 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-8l-2-2z"/></svg>Select Directory</label>
                                        <input type="file" id="fileBrowser" webkitdirectory multiple hidden>
                                    </div>
                                    <div id="pi-file-controls" style="display:none;" class="pi-controls">
                                        <input type="text" id="pi-ip" placeholder="IP (e.g. 192.168.1.173)">
                                        <div style="display:flex; gap:0.25rem;">
                                            <input type="text" id="pi-user" placeholder="User" style="width:50%">
                                            <input type="password" id="pi-pass" placeholder="Pass" style="width:50%">
                                        </div>
                                        <div class="checkbox-group" style="margin-bottom:0; padding:0; justify-content: center;">
                                            <input type="checkbox" id="pi-use-proxy">
                                            <label for="pi-use-proxy" style="font-size:0.8rem; color:var(--text-muted-color);">Use Proxy (localhost:8000)</label>
                                        </div>
                                        <button class="btn" id="pi-connect-btn">Connect</button>
                                    </div>
                                    <select id="date-select" class="styled-input"><option>Select Event</option></select>
                                </div>
                            </div>
                            <div class="header-row progress-container">
                                <div id="event-marker"></div>
                                <div id="timeline-markers"></div>
                                <div id="scrubber-tooltip">00:00</div>
                                <input type="range" id="master-scrubber" min="0" max="100" value="0" step="0.1">
                            </div>
                    </div>
                    <div id="collapsible-controls" class="collapsible-panel">
                            <div class="panel-section">
                                <div class="camera-toggles" id="camera-toggles">
                                    <label class="toggle-label" for="select-all-cameras">All Cameras<label class="switch"><input type="checkbox" id="select-all-cameras" checked><span class="slider"></span></label></label>
                                    <div class="divider"></div>
                                    <label class="toggle-label" for="cam-front">Front<label class="switch"><input type="checkbox" id="cam-front" data-camera="front" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-back">Back<label class="switch"><input type="checkbox" id="cam-back" data-camera="back" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-left-repeater">L Fender<label class="switch"><input type="checkbox" id="cam-left-repeater" data-camera="left_repeater" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-right-repeater">R Fender<label class="switch"><input type="checkbox" id="cam-right-repeater" data-camera="right_repeater" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-left-pillar">L Pillar<label class="switch"><input type="checkbox" id="cam-left-pillar" data-camera="left_pillar" checked><span class="slider"></span></label></label>
                                    <label class="toggle-label" for="cam-right-pillar">R Pillar<label class="switch"><input type="checkbox" id="cam-right-pillar" data-camera="right_pillar" checked><span class="slider"></span></label></label>
                                </div>
                            </div>
                    </div>
             </div>
             <div class="video-grid-container">
                    <div class="video-grid" id="video-grid">
                        <div class="video-container front">
                            <div class="video-label">Front</div>
                            <video class="front p1 active" muted playsinline></video>
                            <video class="front p2" muted playsinline></video>
                        </div>
                        <div class="video-container back">
                            <div class="video-label">Back</div>
                            <video class="back p1 active" muted playsinline></video>
                            <video class="back p2" muted playsinline></video>
                        </div>
                        <div class="video-container left_repeater">
                            <div class="video-label">Left Fender</div>
                            <video class="left_repeater p1 active" muted playsinline></video>
                            <video class="left_repeater p2" muted playsinline></video>
                        </div>
                        <div class="video-container right_repeater">
                            <div class="video-label">Right Fender</div>
                            <video class="right_repeater p1 active" muted playsinline></video>
                            <video class="right_repeater p2" muted playsinline></video>
                        </div>
                        <div class="video-container left_pillar">
                            <div class="video-label">Left Pillar</div>
                            <video class="left_pillar p1 active" muted playsinline></video>
                            <video class="left_pillar p2" muted playsinline></video>
                        </div>
                        <div class="video-container right_pillar">
                            <div class="video-label">Right Pillar</div>
                            <video class="right_pillar p1 active" muted playsinline></video>
                            <video class="right_pillar p2" muted playsinline></video>
                        </div>
                    </div>
             </div>
        </div>
</div>

<div id="map-container">
    <div id="map-close-button">Ã—</div>
    <iframe id="map-iframe" src="" frameborder="0" allowfullscreen></iframe>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const state = {
            playbackRate: 1, carouselIndex: 0, eventClips: new Map(),
            sortedEventKeys: [], currentEventData: {},
            cameraSource: 'local', 
            piConfig: { ip: '', user: '', pass: '', useProxy: false },
            eventsMap: new Map(), 
            dayEvents: [], 
            currentActiveEvent: null,
            activePlayer: 'p1', // 'p1' or 'p2'
            loadingBlob: false
        };

        const dom = {
            body: document.body,
            videoGrid: document.querySelector("#video-grid"),
            // Select ACTIVE videos for playback control
            // We will manage this dynamically
            fileBrowser: document.querySelector("#fileBrowser"),
            dateSelector: document.querySelector("#date-select"),
            nextButton: document.querySelector("button.next"),
            previousButton: document.querySelector("button.previous"),
            masterScrubber: document.querySelector("#master-scrubber"),
            liveTimestamp: document.querySelector("#live-timestamp"),
            durationDisplay: document.querySelector("#duration-display"),
            playPauseButton: document.querySelector("#play-pause-button"),
            playIcon: document.querySelector("#play-icon"), 
            pauseIcon: document.querySelector("#pause-icon"),
            statusDot: document.querySelector('.status-dot'),
            eventMarker: document.querySelector("#event-marker"),
            jumpToEventButton: document.querySelector("#jump-to-event"),
            mapButton: document.getElementById('map-button'),
            mapContainer: document.getElementById('map-container'),
            mapIframe: document.getElementById('map-iframe'),
            mapCloseButton: document.getElementById('map-close-button'),
            cameraToggles: document.querySelector("#camera-toggles"),
            selectAllCameras: document.querySelector('#select-all-cameras'),
            themeToggle: document.querySelector('#theme-toggle'),
            themeIconSun: document.querySelector('#theme-icon-sun'),
            themeIconMoon: document.querySelector('#theme-icon-moon'),
            fullscreenToggle: document.getElementById('fullscreen-toggle'),
            maximizeIcon: document.getElementById('maximize-icon'),
            minimizeIcon: document.getElementById('minimize-icon'),
            skipForwardButton: document.querySelector('#skip-forward'),
            skipRewindButton: document.querySelector('#skip-rewind'),
            playbackSpeedSelector: document.querySelector('#playback-speed'),
            speedDisplay: document.querySelector('#speed-display'),
            resetSpeedBtn: document.querySelector('#reset-speed'),
            scrubberTooltip: document.getElementById('scrubber-tooltip'),
            timelineMarkersContainer: document.getElementById('timeline-markers'),
            collapsibleControls: document.querySelector('#collapsible-controls'),
            titleFolderName: document.querySelector('.title-folder-name'),
            eventDetailsContainer: document.getElementById('event-details-container'),
            eventReasonDisplay: document.getElementById('event-reason-display'),
            eventTimeDisplay: document.getElementById('event-time-display'),
            eventTriggerDisplay: document.getElementById('event-trigger-display'),
            eventCityDisplay: document.getElementById('event-city-display'),
            screenshotBtn: document.querySelector('#screenshot-btn'),
            cameraControlsContainer: document.getElementById('camera-controls-container'),
            btnSourceLocal: document.getElementById('btn-source-local'),
            btnSourcePi: document.getElementById('btn-source-pi'),
            localFileControls: document.getElementById('local-file-controls'),
            piFileControls: document.getElementById('pi-file-controls'),
            piIpInput: document.getElementById('pi-ip'),
            piUserInput: document.getElementById('pi-user'),
            piPassInput: document.getElementById('pi-pass'),
            piUseProxy: document.getElementById('pi-use-proxy'),
            piConnectBtn: document.getElementById('pi-connect-btn'),
        };
        
        // Helpers to get active videos
        function getActiveVideos() {
            return document.querySelectorAll(`video.${state.activePlayer}`);
        }
        function getNextVideos() {
            return document.querySelectorAll(`video.${state.activePlayer === 'p1' ? 'p2' : 'p1'}`);
        }
        function getFrontVideo() {
            return document.querySelector(`video.front.${state.activePlayer}`);
        }

        const friendlyEventReasons = {
            'sentry_aware_object_detection': 'Sentry: Object Detected',
            'user_interaction_dashcam_icon_tapped': 'Dashcam Saved (Manual)',
            'user_interaction_honk': 'Dashcam Saved (Honk)',
            'sentry_locked_handle_pulled': 'Sentry: Handle Pulled',
            'user_interaction_dashcam_multifunction_selected': 'Dashcam Saved (Manual)',
        };

        window.switchCameraSource = (source) => {
            state.cameraSource = source;
            if (source === 'local') {
                dom.btnSourceLocal.classList.add('active');
                dom.btnSourcePi.classList.remove('active');
                dom.localFileControls.style.display = 'block';
                dom.piFileControls.style.display = 'none';
            } else {
                dom.btnSourceLocal.classList.remove('active');
                dom.btnSourcePi.classList.add('active');
                dom.localFileControls.style.display = 'none';
                dom.piFileControls.style.display = 'flex';
                if (localStorage.getItem('piConfig')) {
                    const saved = JSON.parse(localStorage.getItem('piConfig'));
                    dom.piIpInput.value = saved.ip || '';
                    dom.piUserInput.value = saved.user || '';
                    dom.piPassInput.value = saved.pass || '';
                    dom.piUseProxy.checked = saved.useProxy || false;
                }
            }
            resetViewer();
        };

        function resetViewer() {
            state.eventClips.clear();
            state.sortedEventKeys = [];
            state.eventsMap.clear();
            dom.dateSelector.innerHTML = '<option>Select Event</option>';
            dom.titleFolderName.textContent = 'No Clips Selected';
            // Clear all videos
            document.querySelectorAll('video').forEach(v => v.src = '');
            dom.eventDetailsContainer.style.display = 'none';
            dom.liveTimestamp.textContent = "00:00";
            dom.durationDisplay.textContent = "00:00";
            dom.masterScrubber.value = 0;
            dom.eventMarker.style.display = "none";
            dom.timelineMarkersContainer.innerHTML = '';
            dom.jumpToEventButton.style.display = "none";
            dom.mapButton.style.display = 'none';
            state.activePlayer = 'p1';
            updatePlayerVisibility();
        }
        
        function updatePlayerVisibility() {
            document.querySelectorAll('.video-container video').forEach(v => v.classList.remove('active'));
            document.querySelectorAll(`.video-container video.${state.activePlayer}`).forEach(v => v.classList.add('active'));
        }
        
        const applyTheme = (theme) => {
            if (theme === 'light') {
                dom.body.classList.add('light-mode');
                dom.themeIconSun.style.display = 'none';
                dom.themeIconMoon.style.display = 'block';
            } else {
                dom.body.classList.remove('light-mode');
                dom.themeIconSun.style.display = 'block';
                dom.themeIconMoon.style.display = 'none';
            }
        }

        async function connectToPi() {
            const ip = dom.piIpInput.value.trim();
            const user = dom.piUserInput.value.trim();
            const pass = dom.piPassInput.value.trim();
            const useProxy = dom.piUseProxy.checked;

            if (!ip) {
                alert("Please enter an IP address.");
                return;
            }

            state.piConfig = { ip, user, pass, useProxy };
            localStorage.setItem('piConfig', JSON.stringify(state.piConfig));

            dom.titleFolderName.textContent = "Connecting...";
            
            const authHeaders = new Headers();
            if (user && pass) {
                authHeaders.set('Authorization', 'Basic ' + btoa(user + ":" + pass));
            }

            try {
                const baseUrl = ip.startsWith('http') ? ip : `http://${ip}`;
                let url = `${baseUrl}/cgi-bin/videolist.sh`;
                
                if (useProxy) {
                    url = `http://localhost:8000/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(url, { headers: authHeaders });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                processRemoteFileList(text, baseUrl, authHeaders);

            } catch (error) {
                console.error("Connection failed:", error);
                dom.titleFolderName.textContent = "Connection Failed";
                alert(`Failed to connect to ${ip}.\n\nError: ${error.message}\n\nNote: If accessing from a local file, browser security (CORS) may block the request.\nTry enabling "Use Proxy" and running the python cors_proxy.py script.`);
            }
        }

        function processRemoteFileList(fileListText, baseUrl, authHeaders) {
            state.eventClips.clear();
            state.sortedEventKeys = [];
            dom.dateSelector.innerHTML = '<option>Select Event</option>';

            const lines = fileListText.split('\n');
            const useProxy = state.piConfig.useProxy;

            const sequenceMetadata = new Map();

            for (const lineRaw of lines) {
                 const line = lineRaw.trim();
                 if (!line) continue;
                 
                 if (line.startsWith('SentryClips') || line.startsWith('SavedClips')) {
                     const parts = line.split('/');
                     if (parts.length >= 2) {
                         const group = parts[0];
                         const sequenceName = parts[1];
                         const filename = parts.length > 2 ? parts[parts.length - 1] : '';
                         
                         if (!sequenceMetadata.has(sequenceName)) {
                             sequenceMetadata.set(sequenceName, { 
                                 minTime: null, 
                                 maxTime: null, 
                                 jsonPath: null, 
                                 type: group === 'SentryClips' ? 'sentry' : 'saved' 
                             });
                         }
                         
                         const meta = sequenceMetadata.get(sequenceName);
                         
                         if (filename === 'event.json') {
                             let jsonUrl = `${baseUrl}/TeslaCam/${line}`;
                             if (useProxy) jsonUrl = `http://localhost:8000/proxy?url=${encodeURIComponent(jsonUrl)}`;
                             meta.jsonPath = jsonUrl;
                         } else if (filename.endsWith('.mp4')) {
                             const match = filename.match(/^(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                             if (match) {
                                 const isoTime = match[1].substring(0, 10) + 'T' + match[1].substring(11).replace(/-/g, ':');
                                 const time = new Date(isoTime).getTime();
                                 if (meta.minTime === null || time < meta.minTime) meta.minTime = time;
                                 if (meta.maxTime === null || time > meta.maxTime) meta.maxTime = time;
                             }
                         }
                     }
                 }
            }

            const eventsMap = new Map(); 
            sequenceMetadata.forEach((meta, seqName) => {
                if (meta.minTime) {
                     const dateStr = new Date(meta.minTime).toISOString().substring(0, 10);
                     if (!eventsMap.has(dateStr)) eventsMap.set(dateStr, []);
                     eventsMap.get(dateStr).push({
                         sequenceName: seqName,
                         startTime: meta.minTime,
                         endTime: meta.maxTime || meta.minTime,
                         type: meta.type,
                         jsonPath: meta.jsonPath
                     });
                }
            });
            state.eventsMap = eventsMap;

            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line) continue;

                const parts = line.split('/');
                if (parts.length < 3) continue;

                const [group, sequenceName, filename] = parts;
                
                if (!['RecentClips', 'SavedClips', 'SentryClips'].includes(group)) continue;
                
                if (!state.eventClips.has(sequenceName)) {
                    state.eventClips.set(sequenceName, { 
                        playlists: { front: [], back: [], left_repeater: [], right_repeater: [], left_pillar: [], right_pillar: [] }, 
                        eventJson: null, 
                        fullPath: line,
                        isRemote: true,
                        baseUrl: baseUrl,
                        authHeaders: authHeaders
                    });
                }

                const eventData = state.eventClips.get(sequenceName);
                
                let cameraType = null;
                if (filename.includes('front')) cameraType = 'front';
                else if (filename.includes('back')) cameraType = 'back';
                else if (filename.includes('left_repeater')) cameraType = 'left_repeater';
                else if (filename.includes('right_repeater')) cameraType = 'right_repeater';
                else if (filename.includes('left_pillar')) cameraType = 'left_pillar';
                else if (filename.includes('right_pillar')) cameraType = 'right_pillar';

                if (cameraType && filename.endsWith('.mp4')) {
                    let fakeName = filename;
                    if (!filename.match(/^\d{4}-\d{2}-\d{2}/)) {
                        fakeName = `${sequenceName}-${filename}`;
                    }

                    let fileUrl = `${baseUrl}/TeslaCam/${line}`;
                    if (useProxy) {
                        fileUrl = `http://localhost:8000/proxy?url=${encodeURIComponent(fileUrl)}`;
                    }

                    const remoteFile = {
                        name: fakeName,
                        url: fileUrl, 
                        isRemote: true
                    };
                    eventData.playlists[cameraType].push(remoteFile);
                }
            }

            for (const [_, data] of state.eventClips.entries()) { 
                for (const camera in data.playlists) {
                    data.playlists[camera].sort((a, b) => a.name.localeCompare(b.name));
                }
            }

            const allKeys = Array.from(state.eventClips.keys()).sort();
            state.sortedEventKeys = allKeys; 
            
            const dateKeys = allKeys.filter(k => k.match(/^\d{4}-\d{2}-\d{2}$/));
            
            if (dateKeys.length === 0 && allKeys.length === 0) {
                dom.titleFolderName.textContent = 'No Clips Found on Pi';
                dom.dateSelector.innerHTML = '<option>No Events Found</option>';
                return;
            }

            dom.dateSelector.innerHTML = '';
            const keysToShow = dateKeys.length > 0 ? dateKeys : allKeys;
            
            keysToShow.forEach((key) => { 
                const index = state.sortedEventKeys.indexOf(key);
                const option = document.createElement("option"); 
                
                const dateMatch = key.match(/^(\d{4}-\d{2}-\d{2})/);
                if (dateMatch && key.length === 10) {
                     const dateStr = dateMatch[1];
                     const eventsForDate = eventsMap.get(dateStr);
                     const eventCount = eventsForDate ? eventsForDate.length : 0;
                     option.innerText = `${key} (${eventCount} events)`;
                } else {
                    option.innerText = key;
                }
                
                option.value = index; 
                dom.dateSelector.appendChild(option); 
            });
            
            dom.titleFolderName.textContent = `Found ${keysToShow.length} Days`;
            
            if (dom.dateSelector.options.length > 0) {
                dom.dateSelector.selectedIndex = 0;
                loadEvent(parseInt(dom.dateSelector.value));
            }
        }

        async function displayEventDetails(eventInfo) {
            if (!eventInfo.jsonPath) {
                dom.eventDetailsContainer.style.display = 'block';
                dom.eventReasonDisplay.innerHTML = `Event: <strong>${eventInfo.type === 'sentry' ? 'Sentry Event' : 'Saved Clip'}</strong>`;
                dom.eventTimeDisplay.innerHTML = `Time: <strong>${formatLocalTime(new Date(eventInfo.startTime))}</strong>`;
                dom.eventTriggerDisplay.innerHTML = '';
                dom.eventCityDisplay.innerHTML = '';
                dom.mapButton.style.display = 'none';
                return;
            }
            
            try {
                const headers = state.piConfig.user ? new Headers({'Authorization': 'Basic ' + btoa(state.piConfig.user + ":" + state.piConfig.pass)}) : new Headers();
                const res = await fetch(eventInfo.jsonPath, { headers });
                const jsonData = await res.json();
                
                dom.eventDetailsContainer.style.display = 'block';
                const friendlyReason = friendlyEventReasons[jsonData.reason] || jsonData.reason.replace(/_/g, ' ');
                dom.eventReasonDisplay.innerHTML = `Event: <strong>${friendlyReason}</strong>`;
                dom.eventTimeDisplay.innerHTML = `Time: <strong>${formatLocalTime(new Date(jsonData.timestamp))}</strong>`;
                
                if (jsonData.city) {
                    dom.eventCityDisplay.innerHTML = `City: <strong>${jsonData.city}</strong>`;
                } else {
                    dom.eventCityDisplay.innerHTML = '';
                }
                
                if (jsonData.est_lat && jsonData.est_lon) {
                    state.currentEventData.location = { lat: jsonData.est_lat, lon: jsonData.est_lon };
                    dom.mapButton.style.display = 'inline-flex';
                } else {
                    dom.mapButton.style.display = 'none';
                }

            } catch (e) {
                console.error("Error fetching event json", e);
            }
        }

        async function loadEvent(index) {
            state.carouselIndex = index;
            if (index < 0 || index >= state.sortedEventKeys.length) return;
            pauseVideos();
            dom.masterScrubber.value = 0;
            dom.liveTimestamp.textContent = "00:00";
            dom.durationDisplay.textContent = "00:00";
            dom.eventMarker.style.display = "none";
            dom.jumpToEventButton.style.display = "none";
            dom.mapButton.style.display = 'none';
            dom.eventDetailsContainer.style.display = 'none';
            dom.timelineMarkersContainer.innerHTML = '';
            state.dayEvents = [];
            state.currentActiveEvent = null;
            state.activePlayer = 'p1';
            updatePlayerVisibility();
            document.querySelectorAll('.video-container').forEach(c => c.classList.remove('triggered'));

            const eventKey = state.sortedEventKeys[index];
            const eventData = state.eventClips.get(eventKey);
            state.currentEventData = {
                playlists: eventData.playlists, clipDurations: [],
                totalDuration: 0, eventTriggerOffset: -1, firstClipTime: null,
                playlistIndices: { front: 0, back: 0, left_repeater: 0, right_repeater: 0, left_pillar: 0, right_pillar: 0 }
            };
            dom.titleFolderName.textContent = eventKey;
            dom.dateSelector.value = index; 

            let earliestFile = null;
            for (const camera in eventData.playlists) {
                if (eventData.playlists[camera].length > 0) {
                    if (!earliestFile || eventData.playlists[camera][0].name < earliestFile.name) {
                        earliestFile = eventData.playlists[camera][0];
                    }
                }
            }

            if (!earliestFile) return;

            const firstClipNameMatch = earliestFile.name.match(/^(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
            if (firstClipNameMatch) {
                const dateTimeString = firstClipNameMatch[1];
                const formattedDateTimeString = dateTimeString.substring(0, 10) + 'T' + dateTimeString.substring(11).replace(/-/g, ':');
                state.currentEventData.firstClipTime = new Date(formattedDateTimeString);
            } else {
                state.currentEventData.firstClipTime = null;
            }
            
            if (eventData.isRemote) {
                dom.titleFolderName.textContent = `${eventKey} (Buffering...)`;
            }

            const masterPlaylist = state.currentEventData.playlists.front;
            if(masterPlaylist.length > 0) {
                state.currentEventData.clipDurations = await Promise.all(masterPlaylist.map(getVideoDuration));
                state.currentEventData.totalDuration = state.currentEventData.clipDurations.reduce((a, b) => a + b, 0);
            } else {
                state.currentEventData.clipDurations = [];
                state.currentEventData.totalDuration = 0;
            }

            if (state.currentEventData.firstClipTime) {
                updateLiveTimestamp(0);
                const endClipTime = new Date(state.currentEventData.firstClipTime.getTime() + (state.currentEventData.totalDuration * 1000));
                dom.durationDisplay.textContent = formatLocalTime(endClipTime);
            } else {
                dom.liveTimestamp.textContent = formatTime(0);
                dom.durationDisplay.textContent = formatTime(state.currentEventData.totalDuration);
            }
            
            if (eventData.isRemote) {
                 dom.titleFolderName.textContent = eventKey;
            }

            // Day Events
            if (state.currentEventData.firstClipTime && state.currentEventData.totalDuration > 0) {
                 const dateStr = eventKey.substring(0, 10);
                 if (state.eventsMap && state.eventsMap.has(dateStr)) {
                     const events = state.eventsMap.get(dateStr);
                     const dayStart = state.currentEventData.firstClipTime.getTime();

                     events.forEach((ev) => {
                         const startOffset = (ev.startTime - dayStart) / 1000;
                         const endOffset = (ev.endTime - dayStart) / 1000 + 60; 
                         
                         if (endOffset > 0 && startOffset < state.currentEventData.totalDuration) {
                             state.dayEvents.push({
                                 startOffset: Math.max(0, startOffset),
                                 endOffset: Math.min(state.currentEventData.totalDuration, endOffset),
                                 jsonPath: ev.jsonPath,
                                 type: ev.type,
                                 startTime: ev.startTime
                             });
                             if (startOffset >= 0 && startOffset <= state.currentEventData.totalDuration) {
                                 const marker = document.createElement('div');
                                 marker.className = `timeline-marker ${ev.type}`;
                                 marker.style.left = `${(startOffset / state.currentEventData.totalDuration) * 100}%`;
                                 marker.title = `${ev.type === 'sentry' ? 'Sentry' : 'Saved'}: ${formatLocalTime(new Date(ev.startTime))}`;
                                 
                                 marker.addEventListener('click', (e) => {
                                     e.stopPropagation();
                                     seekAllVideos(startOffset);
                                 });
                                 dom.timelineMarkersContainer.appendChild(marker);
                             }
                         }
                     });
                 }
            }

            // Initial Load + Preload
            const loadPromises = [];
            const cameraTypes = ['front', 'back', 'left_repeater', 'right_repeater', 'left_pillar', 'right_pillar'];
            
            cameraTypes.forEach(camera => {
                const playlist = state.currentEventData.playlists[camera];
                if (playlist && playlist.length > 0) {
                    const p1 = document.querySelector(`video.${camera}.p1`);
                    const p2 = document.querySelector(`video.${camera}.p2`);
                    
                    // Load first clip into P1
                    loadPromises.push(loadVideo(p1, playlist[0]));
                    
                    // Preload second clip into P2 (if exists)
                    if (playlist.length > 1) {
                        loadVideo(p2, playlist[1]); // Don't await
                    }
                }
            });
            
            await Promise.all(loadPromises);
        }

        function loadVideo(videoElement, file) {
            return new Promise(async (resolve) => {
                videoElement.preload = "auto";
                videoElement.oncanplay = null; 
                videoElement.onerror = null;

                if (!file) {
                    videoElement.src = '';
                    resolve();
                    return;
                }
                
                const onReady = () => {
                     videoElement.playbackRate = state.playbackRate;
                     resolve();
                };

                videoElement.addEventListener('canplay', onReady, { once: true });
                videoElement.addEventListener('error', (e) => {
                    console.error(`Error loading video file: ${file.name}`, e);
                    resolve();
                }, { once: true });

                if (file.isRemote) {
                    if (!file.blobUrl) {
                         try {
                             const headers = state.piConfig.user ? new Headers({'Authorization': 'Basic ' + btoa(state.piConfig.user + ":" + state.piConfig.pass)}) : new Headers();
                             const res = await fetch(file.url, { headers });
                             const blob = await res.blob();
                             file.blobUrl = URL.createObjectURL(blob);
                         } catch (e) {
                             console.error("Failed to fetch video blob", e);
                             resolve();
                             return;
                         }
                    }
                    videoElement.src = file.blobUrl;
                } else {
                    videoElement.src = URL.createObjectURL(file);
                }
            });
        }

        function updatePlayButtonUI(isPlaying) {
            dom.playIcon.style.display = isPlaying ? 'none' : 'block';
            dom.pauseIcon.style.display = isPlaying ? 'block' : 'none';
            dom.statusDot.classList.toggle('ready', !isPlaying);
            dom.statusDot.classList.toggle('playing', isPlaying);
        }
        function playVideos() {
            updatePlayButtonUI(true);
            getActiveVideos().forEach(v => { 
                if (v.src && v.paused) {
                    v.playbackRate = state.playbackRate;
                    v.play().catch(error => console.error(`Play failed for ${v.className}:`, error));
                }
            });
        }
        function pauseVideos() { updatePlayButtonUI(false); getActiveVideos().forEach(v => v.pause()); }
        function playPause() { 
            const front = getFrontVideo();
            front && !front.paused ? pauseVideos() : playVideos();
        }
        function skipTo(seconds) { seekAllVideos(getCurrentTime() + seconds); }
        function setPlaybackSpeed(rate) {
            state.playbackRate = parseFloat(rate);
            // Update ALL videos (active and inactive)
            document.querySelectorAll('video').forEach(video => { video.playbackRate = state.playbackRate; });
            dom.speedDisplay.textContent = state.playbackRate + 'x';
        }
        
        function seekAllVideos(targetTime) {
            if (isNaN(targetTime)) targetTime = 0;
            targetTime = Math.max(0, Math.min(targetTime, state.currentEventData.totalDuration));
            
            // Find correct clip index for this time
            let timeIntoPlaylist = 0;
            let targetClipIndex = -1;
            for (let i = 0; i < state.currentEventData.clipDurations.length; i++) {
                if (targetTime <= timeIntoPlaylist + state.currentEventData.clipDurations[i] + 0.1) {
                    targetClipIndex = i; break;
                }
                timeIntoPlaylist += state.currentEventData.clipDurations[i];
            }
            if (targetClipIndex === -1) targetClipIndex = state.currentEventData.clipDurations.length - 1;
            
            const timeInTargetClip = targetTime - timeIntoPlaylist;
            const wasPlaying = !getFrontVideo().paused;
            
            // Update indices
            const cameraTypes = ['front', 'back', 'left_repeater', 'right_repeater', 'left_pillar', 'right_pillar'];
            cameraTypes.forEach(camera => {
                state.currentEventData.playlistIndices[camera] = targetClipIndex;
                
                // For seeking, we might need to load into ACTIVE player
                const playlist = state.currentEventData.playlists[camera];
                if (playlist && playlist[targetClipIndex]) {
                    const activeVid = document.querySelector(`video.${camera}.${state.activePlayer}`);
                    // If src matches, just seek. If not, load.
                    // Use blob check or src check
                    const file = playlist[targetClipIndex];
                    const srcMatch = (file.isRemote && file.blobUrl === activeVid.src) || (!file.isRemote && activeVid.src.includes(file.name)); // Rough check
                    
                    // Actually, just reload to be safe or if simple seek fails
                    // But we implemented dual player.
                    // Seeking is complex with dual player.
                    // Simplest: Load target into Active. Load target+1 into Inactive.
                    
                    loadVideo(activeVid, file).then(() => {
                         activeVid.currentTime = timeInTargetClip;
                         if (wasPlaying) activeVid.play();
                    });
                    
                    // Preload next
                    const inactivePlayer = state.activePlayer === 'p1' ? 'p2' : 'p1';
                    const inactiveVid = document.querySelector(`video.${camera}.${inactivePlayer}`);
                    if (targetClipIndex + 1 < playlist.length) {
                        loadVideo(inactiveVid, playlist[targetClipIndex + 1]);
                    }
                }
            });
        }
        
        function getCurrentTime() {
            if(!state.currentEventData?.clipDurations?.length) return 0;
            let elapsed = 0;
            for (let i = 0; i < state.currentEventData.playlistIndices.front; i++) {
                elapsed += (state.currentEventData.clipDurations[i] || 0);
            }
            const front = getFrontVideo();
            return elapsed + (front ? front.currentTime : 0);
        }
        
        function updateLiveTimestamp(currentTimeOverride) {
            const currentTime = currentTimeOverride !== undefined ? currentTimeOverride : getCurrentTime();
            if (!state.currentEventData.firstClipTime) {
                dom.liveTimestamp.textContent = formatTime(currentTime);
                return;
            }
            const liveTime = new Date(state.currentEventData.firstClipTime.getTime() + (currentTime * 1000));
            dom.liveTimestamp.textContent = formatLocalTime(liveTime);
        }
        function updateEventMarkerPosition() { if (state.currentEventData.eventTriggerOffset > 0 && state.currentEventData.totalDuration > 0) dom.eventMarker.style.left = `${(state.currentEventData.eventTriggerOffset / state.currentEventData.totalDuration) * 100}%`; }
        function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return "0:00"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs.toString().padStart(2, '0')}`; }
        
        function formatLocalTime(date) { 
            if (!date || isNaN(date.getTime())) return '--:--:--'; 
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }); 
        }

        function getVideoDuration(file) { 
            return new Promise(resolve => { 
                if (file.isRemote) {
                    resolve(60);
                    return;
                }
                const v = document.createElement('video'); 
                v.preload = 'metadata'; 
                v.onloadedmetadata = () => { 
                    URL.revokeObjectURL(v.src); 
                    resolve(v.duration); 
                }; 
                v.onerror = () => resolve(0); 
                v.src = URL.createObjectURL(file); 
            }); 
        }
        
        function toggleFullscreen() {
            dom.body.classList.toggle('fullscreen-active');
            const isFullscreen = dom.body.classList.contains('fullscreen-active');
            dom.maximizeIcon.style.display = isFullscreen ? 'none' : 'block';
            dom.minimizeIcon.style.display = isFullscreen ? 'block' : 'none';
        }

        function closeMap() {
            dom.mapContainer.style.display = 'none';
            dom.mapIframe.src = '';
        }

        // --- Attach Event Listeners ---
        dom.piConnectBtn.addEventListener('click', connectToPi);
        dom.themeToggle.addEventListener('click', () => {
            const newTheme = dom.body.classList.contains('light-mode') ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        });
        dom.playPauseButton.addEventListener('click', playPause);
        dom.dateSelector.addEventListener("change", (e) => loadEvent(parseInt(e.target.value)));
        dom.nextButton.addEventListener("click", () => { if (state.carouselIndex < state.sortedEventKeys.length - 1) loadEvent(++state.carouselIndex); });
        dom.previousButton.addEventListener("click", () => { if (state.carouselIndex > 0) loadEvent(--state.carouselIndex); });
        dom.jumpToEventButton.addEventListener("click", () => seekAllVideos(state.currentEventData.eventTriggerOffset));
        dom.skipForwardButton.addEventListener('click', () => skipTo(5));
        dom.skipRewindButton.addEventListener('click', () => skipTo(-5));
        dom.playbackSpeedSelector.addEventListener('input', (e) => {
             let val = parseInt(e.target.value);
             let speed;
             if (val <= 50) {
                 speed = 0.25 + (val / 50) * 0.75;
             } else {
                 speed = 1.0 + ((val - 50) / 50) * 14.0;
             }
             if (speed > 1) speed = Math.round(speed * 10) / 10;
             else speed = Math.round(speed * 100) / 100;
             
             setPlaybackSpeed(speed);
        });
        
        dom.resetSpeedBtn.addEventListener('click', () => {
            dom.playbackSpeedSelector.value = 50; 
            setPlaybackSpeed(1.0);
        });
        
        dom.masterScrubber.addEventListener('mousemove', (e) => {
            if (!state.currentEventData.totalDuration) return;
            const rect = dom.masterScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            const percentage = Math.max(0, Math.min(1, x / width));
            const time = percentage * state.currentEventData.totalDuration;
            dom.scrubberTooltip.style.left = `${percentage * 100}%`;
            dom.scrubberTooltip.style.opacity = '1';
            if (state.currentEventData.firstClipTime) {
                 const hoverTime = new Date(state.currentEventData.firstClipTime.getTime() + (time * 1000));
                 dom.scrubberTooltip.textContent = formatLocalTime(hoverTime);
            } else {
                 dom.scrubberTooltip.textContent = formatTime(time);
            }
        });
        dom.masterScrubber.addEventListener('mouseout', () => {
            dom.scrubberTooltip.style.opacity = '0';
        });

        // Listen to ALL videos for ended/timeupdate?
        // No, only Active Front video drives the scrubber.
        // But ANY active video ending triggers next.
        // We need to attach listeners to all video elements.
        
        // Wait, `dom.allVideos` contains p1 AND p2.
        // We need to ensure we only react to the ACTIVE player's events.
        
        document.querySelectorAll('video').forEach(video => {
            video.addEventListener("timeupdate", (e) => {
                if (!e.target.classList.contains('active') || !e.target.classList.contains('front')) return;
                
                if (!state.currentEventData.totalDuration || dom.masterScrubber.matches(':active')) return;
                dom.masterScrubber.value = (getCurrentTime() / state.currentEventData.totalDuration) * 100;
                updateLiveTimestamp();
                
                if (state.dayEvents && state.dayEvents.length > 0) {
                    const currentTime = getCurrentTime();
                    const activeEvent = state.dayEvents.find(e => currentTime >= e.startOffset && currentTime <= e.endOffset);
                    
                    if (activeEvent) {
                        if (state.currentActiveEvent !== activeEvent) {
                            state.currentActiveEvent = activeEvent;
                            displayEventDetails(activeEvent);
                        }
                    } else {
                        if (state.currentActiveEvent) {
                            state.currentActiveEvent = null;
                            dom.eventDetailsContainer.style.display = 'none';
                            dom.mapButton.style.display = 'none';
                        }
                    }
                }
            });

            video.addEventListener("ended", async (e) => {
                if (!e.target.classList.contains('active')) return; // Ignore inactive players
                
                const camera = e.target.className.split(' ')[0];
                if (!state.currentEventData.playlists || !state.currentEventData.playlists[camera]) return;
                
                const playlist = state.currentEventData.playlists[camera];
                const currentIdx = state.currentEventData.playlistIndices[camera];
                
                if (currentIdx + 1 < playlist.length) {
                    // Swap players
                    // Current active is e.target.
                    // Other player is inactive.
                    const wasPlaying = !e.target.paused; // Should be true if ended naturally
                    
                    // Only swap/update once per camera
                    // Increment index
                    state.currentEventData.playlistIndices[camera]++;
                    
                    // Identify players
                    const p1 = document.querySelector(`video.${camera}.p1`);
                    const p2 = document.querySelector(`video.${camera}.p2`);
                    
                    const nextPlayer = e.target === p1 ? p2 : p1;
                    
                    // Swap classes
                    e.target.classList.remove('active');
                    nextPlayer.classList.add('active');
                    
                    // Play next (already loaded)
                    nextPlayer.playbackRate = state.playbackRate;
                    nextPlayer.play().catch(err => {});
                    
                    // Preload subsequent clip into the NOW inactive player (e.target)
                    if (currentIdx + 2 < playlist.length) {
                        loadVideo(e.target, playlist[currentIdx + 2]);
                    }
                    
                    // Update global active player state if front
                    if (camera === 'front') {
                        state.activePlayer = nextPlayer.classList.contains('p1') ? 'p1' : 'p2';
                    }

                } else if (camera === 'front') {
                    // End of event
                    if (state.carouselIndex < state.sortedEventKeys.length - 1) {
                        await loadEvent(++state.carouselIndex);
                        playVideos();
                    } else {
                        pauseVideos();
                    }
                }
            });
        });
        
        dom.masterScrubber.addEventListener("input", () => { if (state.currentEventData.totalDuration) updateLiveTimestamp((dom.masterScrubber.value / 100) * state.currentEventData.totalDuration); });
        dom.masterScrubber.addEventListener("change", () => { if (state.currentEventData.totalDuration) seekAllVideos((dom.masterScrubber.value / 100) * state.currentEventData.totalDuration); });

        document.querySelectorAll('.video-container').forEach(container => {
            container.addEventListener('dblclick', (e) => {
                const grid = dom.videoGrid;
                const clickedContainer = e.currentTarget;
                if (grid.classList.contains('expanded-view')) {
                    if (clickedContainer.classList.contains('expanded')) {
                        grid.classList.remove('expanded-view');
                        clickedContainer.classList.remove('expanded');
                    }
                } else {
                    grid.classList.add('expanded-view');
                    clickedContainer.classList.add('expanded');
                }
            });
        });
        dom.fileBrowser.addEventListener("change", function(e) {
            state.eventClips.clear(); 
            state.sortedEventKeys = []; 
            dom.dateSelector.innerHTML = '<option>Select Event</option>';
            dom.titleFolderName.textContent = 'No Clips Selected';
            for (const file of e.target.files) {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length < 2) continue;
                const eventId = pathParts[pathParts.length - 2];
                if (!state.eventClips.has(eventId)) state.eventClips.set(eventId, { playlists: { front: [], back: [], left_repeater: [], right_repeater: [], left_pillar: [], right_pillar: [] }, eventJson: null, fullPath: file.webkitRelativePath });
                const group = state.eventClips.get(eventId);
                const videoMatch = file.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})-(.+?)\.mp4$/);
                if (videoMatch && group.playlists[videoMatch[2]]) group.playlists[videoMatch[2]].push(file);
                if (file.name === "event.json") group.eventJson = file;
            }
            for (const [_, data] of state.eventClips.entries()) { for (const camera in data.playlists) data.playlists[camera].sort((a, b) => a.name.localeCompare(b.name)); }
            state.sortedEventKeys = Array.from(state.eventClips.keys()).sort();
            if (state.sortedEventKeys.length === 0) { dom.titleFolderName.textContent = 'No Clips Found'; dom.dateSelector.innerHTML = '<option>No Events Found</option>'; return; }
            dom.dateSelector.innerHTML = '';
            state.sortedEventKeys.forEach((key, index) => { const option = document.createElement("option"); option.innerText = key; option.value = index; dom.dateSelector.appendChild(option); });
            loadEvent(0);
        });
        dom.screenshotBtn.addEventListener('click', () => {
            const visibleContainers = [...dom.videoGrid.querySelectorAll('.video-container:not(.hidden)')];
            if (visibleContainers.length === 0) return;
            // Use ACTIVE video
            const firstVideo = visibleContainers[0].querySelector('video.active');
            if (!firstVideo || !firstVideo.src || firstVideo.videoWidth === 0) return;
            const videoWidth = firstVideo.videoWidth;
            const videoHeight = firstVideo.videoHeight;
            const gridMapping = { left_pillar: { col: 0, row: 0 }, front: { col: 1, row: 0 }, right_pillar: { col: 2, row: 0 }, left_repeater: { col: 0, row: 1 }, back: { col: 1, row: 1 }, right_repeater: { col: 2, row: 1 }, };
            const canvas = document.createElement('canvas');
            canvas.width = videoWidth * 3;
            canvas.height = videoHeight * 2;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            visibleContainers.forEach(container => {
                const video = container.querySelector('video.active');
                const cameraType = [...container.classList].find(c => gridMapping[c]);
                if (cameraType && video && video.videoWidth > 0) {
                    const { col, row } = gridMapping[cameraType];
                    const dx = col * videoWidth;
                    const dy = row * videoHeight;
                    ctx.drawImage(video, dx, dy, videoWidth, videoHeight);
                }
            });
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `Tesla-Companion-Screenshot-${timestamp}.jpg`;
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
        });
        dom.fullscreenToggle.addEventListener('click', toggleFullscreen);
        dom.mapButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (state.currentEventData.location) {
                const { lat, lon } = state.currentEventData.location;
                const mapUrl = `https://www.google.com/maps?q=${lat},${lon}&hl=es;z=14&output=embed`;
                dom.mapIframe.src = mapUrl;
                dom.mapContainer.style.display = 'flex';
            }
        });
        dom.mapCloseButton.addEventListener('click', closeMap);
        dom.mapContainer.addEventListener('click', (e) => { if (e.target === dom.mapContainer) closeMap(); });
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            switch(e.key) {
                case ' ': e.preventDefault(); playPause(); break;
                case 'ArrowLeft': e.preventDefault(); skipTo(-5); break;
                case 'ArrowRight': e.preventDefault(); skipTo(5); break;
                case 'ArrowUp': e.preventDefault(); if (state.carouselIndex > 0) loadEvent(--state.carouselIndex); break;
                case 'ArrowDown': e.preventDefault(); if (state.carouselIndex < state.sortedEventKeys.length - 1) loadEvent(++state.carouselIndex); break;
                case 'Escape': if (dom.body.classList.contains('fullscreen-active')) { toggleFullscreen(); } closeMap(); break;
            }
        });


        // --- Initial App State ---
        applyTheme(localStorage.getItem('theme') || 'dark');
        dom.cameraControlsContainer.style.display = 'block'; 
    });
</script>

</body>
</html>
